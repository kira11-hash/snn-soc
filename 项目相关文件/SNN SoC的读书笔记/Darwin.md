这两篇论文分别代表了浙江大学 **Darwin（达尔文）** 系列的第一代和第三代架构。它们对你最大的价值在于：**如何用“时间复用”来换取面积，以及如何定义一套“SNN 专用指令集”来驱动硬件。**

我们将这两篇合并提取，因为 Darwin3 是 Darwin1 的集大成者。

---

### 第三、四篇：浙江大学 Darwin1 & Darwin3（侧重：专用指令集 ISA 与 连通性压缩）

**【论文名称】**
*   *Darwin: A neuromorphic hardware co-processor based on SNN (2017)*
*   *Darwin3: A large-scale neuromorphic chip with a Novel ISA and On-Chip Learning (2023)*

**1) SoC 相关核心内容（只写 3–5 条）**
*   **神经元时间复用（Time-multiplexing）：** 物理上只有少量神经元硬件单元，通过循环读取 SRAM 中的状态，模拟成成千上万个逻辑神经元。
*   **领域专用指令集（DS-ISA）：** Darwin3 定义了 10 条核心指令（如 `UPTVM` 更新膜电位，`GSPRS` 产生脉冲），像写汇编一样控制 SNN 计算。
*   **异步网格（Mesh NoC）：** 24×24 的计算节点阵列，采用 XY 路由协议处理脉冲包（AER Packet）的传输。
*   **连接压缩技术：** 针对卷积 SNN（CSNN），在硬件层实现权重共享的解压缩，极大地节省了存储神经元连通关系的内存。

**2) 论文里暴露的系统级痛点**
*   **痛点 1：指令冗余。** 如果用通用的 RISC-V 指令跑 SNN 更新，取指/译码能耗占比太高。
*   **痛点 2：存储墙。** SNN 的突触（Synapse）数量远多于神经元，存储这些连接关系消耗了芯片 70% 以上的面积和功耗。
*   **痛点 3：扩展性障碍。** 单个逻辑核能支撑的神经元上限受限于 SRAM 大小，跨核通信（NoC）的延迟会显著拖慢整个系统的 Tick 时钟。

**3) 可转化为 SoC 数字创新点（3–5 条）**
*   **创新点 1（针对痛点 1）：SNN 算子级指令译码器。** 
    *   在 E203 旁边加一个“执行辅助模块”，专门译码 3-4 条类 Darwin3 的宏指令（例如：一条指令完成“读取状态+加权重+写回状态”）。**（✅ V1 推荐：只需在总线上挂一个专用译码状态机）**
*   **创新点 2（针对痛点 2）：硬件连接解压缩（Connection Decompression）。**
    *   CIM 存储的是权重，而“哪个神经元连哪个”存在外部 DRAM 中。设计一个数字模块，在 DMA 搬运时自动根据“间接寻址”计算出目标地址，节省存储空间。**（⚠️ V2 推荐）**
*   **创新点 3（针对 SNN 特性）：两段式流水线同步机制。**
    *   将计算分为“脉冲积累相”和“神经元更新相”，用数字逻辑实现两级 Barrier 同步，确保跨核计算的时序正确。**（✅ V1 推荐：解决功能跑通的稳定性）**

**4) 是否适合短期实现（判断）**
*   ✅ **适合 V1（低风险）：** 
    *   **时间复用控制器：** 让一个 CIM Macro 轮流处理 128 个逻辑神经元的状态更新，这是 V1 跑通大型网络的基础。
    *   **状态变量寄存器堆：** 在数字端实现 Darwin1 的寄存器结构，暂存中间结果。
*   ⚠️ **适合 V2/V3（高风险）：** 
    *   **Darwin3 级别的 ISA：** 定义完整的 SNN 汇编级控制器太复杂，V1 只需要固定功能的 FSM。
    *   **NoC 路由：** 除非你要做多核拼接。

**5) 一句总结**
**Darwin 系列证明了：通过设计“SNN 专用指令集”和“神经元时间复用逻辑”，可以让你在面积受限的数字 SoC 上模拟出百万量级的神经元规模。**

---

### 💡 针对你 V1 版本（6/30）的终极策略：

由于你的 CIM Macro 是外置 IP，且 V1 目标是“跑通和稳定”，我建议你从这四篇论文里挑出以下 **3个数字创新点组合**，放在你的 SoC 里：

1.  **分级控制（来自 SENECA）：** E203 (Master) -> **Task FIFO** -> **Loop Controller (FSM)**。E203 只发一个“开始更新第 N 层”的命令，剩下的循环逻辑由数字 FSM 完成。
2.  **影子寄存器 + 双缓冲（来自 DIANA/Darwin）：** DMA 把下一组神经元数据搬进缓存的同时，CIM 正在算当前组。这样你的 SoC 性能波形会非常漂亮（没有空转）。
3.  **时间复用逻辑（来自 Darwin1）：** 即使你的 CIM Macro 只有一列输出，通过数字端的 SRAM 循环读写，对外宣称你的 SoC 支持“无限多层”的 SNN。

**如果你准备好了，我们可以开始讨论具体的 SoC 顶层架构图（Top-level Block Diagram）该怎么画了。**

体评价：这份 Darwin 的总结“方向上对”，但**落到你当前 V1 的工程**，多数内容只能作为论文动机和对比背景，不适合真做进来。下面我帮你“去噪”，只留真正能转化的点。

**哪些是“可以借鉴/写进论文动机”的**

- **时间复用（Time‑multiplexing）**：它的本质是“用少量硬件虚拟出更多逻辑神经元”。  
    这对你有价值，但**不等于要改 ISA**。你可以说：本 SoC 在控制层面支持分时调度/批处理神经元状态，从而提高资源利用率。  
    ——这可以作为“系统级思想”，**不一定需要新增硬件**。
- **CPU 不应该跑每突触/每神经元的细粒度更新**：Darwin 指出通用 CPU 做 SNN 更新效率低。  
    你现在已有 FSM + DMA + CIM/LIF 流水线的思路，**已经在实践这条原则**。

**哪些“现在不该做”（V1 风险高/不匹配）**

- **Darwin3 级别 DS‑ISA**：改 ISA/改 E203 译码链条是一个中型项目，时间和风险都很高。  
    你现在要“6/30 成功流片”，这个明显不合适。
- **NoC / 异步 AER 路由 / 多核扩展**：你当前架构是单核+单 CIM IP，直接跳到 Darwin 的 NoC 是架构级大改。
- **连接压缩/解压**：这主要针对“稀疏连接图”的数字神经网络存储问题。你现在权重放 CIM，连接关系固定或简单，**性价比不高**。

**对 V1 最合理的“落地方式”**  
把 Darwin 的价值写在“系统策略”里，而不是改硬件：

1. **强调硬件化控制路径**：CPU 发一次命令，控制 FSM 负责整段流程。
2. **强调时间复用/批处理**：将多个逻辑神经元分批进入 CIM/LIF，避免大量重复开销。
3. **强调“低干预 CPU”**：在论文里解释 CPU 不介入细粒度更新，以节能和降低瓶颈。

**如果你坚持要“落地一点点”作为 V2 计划**

- **轻量宏指令（不是改 ISA）**：  
    用“命令 FIFO + 结构化寄存器”实现类似“宏操作”。  
    CPU 写一条命令即可触发“读‑算‑写回”序列，不改 E203 内核。
- **简化版“状态缓存”**：  
    LIF 里引入一个更明显的寄存器级缓存，用来减少 SRAM 读写。