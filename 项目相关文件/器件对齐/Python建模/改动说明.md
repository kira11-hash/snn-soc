# 改动说明（软件层面）

## 1. 项目概览
本项目用于在 Python 中复现 SNN SoC 的 **算法级 dataflow**，并引入器件模型与量化过程，
以评估硬件可实现的准确率与推荐参数。整体流程：
1) 数据预处理（下采样/投影） -> 64 维
2) ANN float 训练得到基线权重
3) 量化/器件模型 + SNN bit‑plane 推理
4) 参数扫描与结果汇总

## 2. 数据流（与 RTL 对齐）
- 输入：28x28 灰度图（uint8, 0~255）
- 预处理：
  - 下采样到 8x8 ： 784->64 投影
  - 输出保持 8‑bit（uint8），确保与 RTL bit‑plane 编码一致
- 推理：
  - bit‑plane 编码（8 bit plane）
  - CIM 差分结构（A 或 B）
  - ADC 量化（固定满量程）
  - LIF 累加、阈值放电、spike count 决策

## 3. 本项目对比了哪些方法/超参数
### 3.1 输入表示方法
- 下采样：
  - `bilinear_8x8`, `nearest_8x8`, `avgpool_8x8`, `maxpool_8x8`
  - `pad32_zero_8x8`, `pad32_replicate_8x8`, `pad32_reflect_8x8`
  - `avgpool_7x7`, `bilinear_7x7`
- 投影（784->64）：
  - `proj_pca_64`：PCA 无监督投影
  - `proj_sup_64`：监督式线性投影

### 3.2 SNN 推理参数
- ADC 位宽：`ADC_BITS_SWEEP`
- 权重量化位宽：`WEIGHT_BITS_SWEEP`
- 推理帧数：`TIMESTEPS_SWEEP`
- 差分方案：A / B
- 决策规则：`decision=spike` / `decision=membrane`
- 器件非理想性：D2D/C2C/噪声/漂移/IR drop
- 阈值方式：固定阈值 / 自适应阈值
- 阈值比例标定：按方法分别在验证集上标定（per-method）

### 3.3 训练阶段参数
- ANN 训练：`ANN_EPOCHS`, `ANN_LR`, `ANN_MOMENTUM`, `ANN_BATCH_SIZE`
- QAT 微调：`QAT_ENABLE`, `QAT_WEIGHT_BITS`, `QAT_NOISE_STD`, `QAT_IR_DROP_COEFF`, `POST_QUANT_FINE_TUNE_EPOCHS`, `QAT_LR`

## 4. 本次新增/调整的关键改动
### 4.1 输入投影
- 新增两种 784->64 投影输入：PCA 与监督式投影
- 投影后统一缩放/量化到 8‑bit，保证与 SNN/RTL 输入一致

### 4.2 阈值标定
- 阈值比例从“测试子集”改为“训练集划分出的验证集”标定，避免测试集泄漏

### 4.3 Summary 规则
- “最佳方法”改为按 **SNN 准确率** 选择（更符合真实硬件运行）

### 4.4 审查修复（must + should）
- 差分阵列 C2C 由“正负共享一组噪声”改为“正负独立噪声”，避免误差被抵消导致高估准确率
- 自适应阈值推理改为 **每个 bit-plane 都进行 fired 检查/复位**，与主推理路径和 RTL 粒度一致
- 自适应阈值路径补齐读噪声注入（与固定阈值路径一致）
- 脉冲触发条件统一为 `>=`（固定阈值/自适应阈值一致）
- 阈值标定删除 test fallback，仅允许验证集标定（避免潜在数据泄漏）
- 阈值标定从“只标定 best_method”改为“每种方法分别标定”
- 噪声实验统计次数从 full=10 提升到 full=30（quick=5）
- 自适应阈值初值估算从 100 样本提升到可配置样本数（默认 `ADAPTIVE_INIT_SAMPLES=512`），并纳入 ADC 量化链路
- `memristor_plugin.py` 改为模块级缓存，避免重复 `exec_module` 造成不必要开销

## 5. 硬件落地指南（保证与 Python 完全一致）
如果你要把输入写入 flash，并保证硬件表现匹配 Python：

### 5.1 先跑一次完整训练
```
python run_all.py
```
这会在 `weights/` 中自动保存投影参数（如 `proj_sup_64_proj_params.pt`）。

### 5.2 生成写入 flash 的 64 维输入
使用脚本 `flash_preprocess.py`，它会严格复用训练中保存的投影与缩放规则：

示例（监督投影，导出 test 集）：
```
python flash_preprocess.py --method proj_sup_64 --split test --out results/proj_sup_64_test_uint8.npy
```
输出文件为 `uint8`，shape=[N,64]，可直接写入 flash。


### 5.2.1 将 .npy 转成 flash 可用的 .bin
如果硬件侧更方便读取裸二进制，可以把 `.npy` 转成 `.bin`：

```
python flash_preprocess.py --method proj_sup_64 --split test --out results/proj_sup_64_test_uint8.npy
```

然后在 Python 中执行：
```
import numpy as np
arr = np.load("results/proj_sup_64_test_uint8.npy")
arr.astype(np.uint8).tofile("results/proj_sup_64_test_uint8.bin")
```

`.bin` 内容为顺序排列的 uint8，等价于二维数组按行平铺。

### 5.3 如果是自定义图像
确保图像满足：
- 灰度图，28x28
- uint8，范围 0~255

然后在 Python 中调用：
```
from flash_preprocess import project_and_quantize
features = project_and_quantize(images_28x28, method_name="proj_sup_64")
```
得到的 `features` 就是与模型一致的 64 维输入。

## 6. 关键配置（config.py）
- 数据处理：`AUTO_INPUT_GAIN`, `INPUT_GAIN_PERCENTILE`, `INPUT_GAIN_MAX`
- 投影：`PROJ_DIM`, `PROJ_PCA_SAMPLES`, `PROJ_PCA_CENTER`, `PROJ_SCALE_METHOD`, `PROJ_SCALE_PERCENTILE`,
        `PROJ_SUP_EPOCHS`, `PROJ_SUP_LR`, `PROJ_SUP_BATCH_SIZE`, `PROJ_SUP_USE_BIAS`
- 阈值标定：`VAL_SAMPLES`, `CALIBRATE_THRESHOLD_RATIO`, `THRESHOLD_RATIO_CANDIDATES`, `THRESHOLD_CALIBRATE_SAMPLES`
- 自适应阈值：`ADAPTIVE_INIT_SAMPLES`, `SPIKE_RESET_MODE`
- QAT：`QAT_ENABLE`, `QAT_WEIGHT_BITS`, `QAT_USE_DEVICE_LEVELS`, `QAT_NOISE_ENABLE`, `QAT_NOISE_STD`,
        `QAT_IR_DROP_COEFF`, `POST_QUANT_FINE_TUNE_EPOCHS`, `QAT_LR`
- 推理：`SPIKE_THRESHOLD_RATIO`, `ADC_FULL_SCALE_MODE`, `NOISE_TRIALS_QUICK`, `NOISE_TRIALS_FULL`

备注：所有改动均为软件层面，不改变硬件结构/RTL。

