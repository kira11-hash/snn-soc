# 改动说明（软件层面）

## 1. 项目概览
本项目用于在 Python 中复现 SNN SoC 的 **算法级 dataflow**，并引入器件模型与量化过程，
以评估硬件可实现的准确率与推荐参数。整体流程：
1) 数据预处理（下采样/投影） -> 64 维或 49 维输入
2) ANN float 训练得到基线权重
3) 量化/器件模型 + SNN bit‑plane 推理
4) 参数扫描与结果汇总

## 2. 数据流（与 RTL 对齐）
- 输入：28x28 灰度图（uint8, 0~255）
- 预处理：
  - 下采样到 8x8 或 7x7，或 784->64 投影
  - 输出保持 8‑bit（uint8），确保与 RTL bit‑plane 编码一致
- 推理：
  - bit‑plane 编码（8 bit plane）
  - CIM 差分结构（A 或 B）
  - ADC 量化（固定满量程）
  - LIF 累加、阈值放电、spike count 决策

## 3. 本项目对比了哪些方法/超参数
### 3.1 输入表示方法
- 下采样：
  - `bilinear_8x8`, `nearest_8x8`, `avgpool_8x8`, `maxpool_8x8`
  - `pad32_zero_8x8`, `pad32_replicate_8x8`, `pad32_reflect_8x8`
  - `avgpool_7x7`, `bilinear_7x7`
- 投影（784->64）：
  - `proj_pca_64`：PCA 无监督投影
  - `proj_sup_64`：监督式线性投影

### 3.2 SNN 推理参数
- ADC 位宽：`ADC_BITS_SWEEP`
- 权重量化位宽：`WEIGHT_BITS_SWEEP`
- 推理帧数：`TIMESTEPS_SWEEP`
- 差分方案：A / B
- 决策规则：`decision=spike` / `decision=membrane`
- 器件非理想性：D2D/C2C/噪声/漂移/IR drop
- 阈值方式：固定阈值 / 自适应阈值
- 阈值比例标定：按方法分别在验证集上标定（per-method）

### 3.3 训练阶段参数
- ANN 训练：`ANN_EPOCHS`, `ANN_LR`, `ANN_MOMENTUM`, `ANN_BATCH_SIZE`
- QAT 微调：`QAT_ENABLE`, `QAT_WEIGHT_BITS`, `QAT_NOISE_STD`, `QAT_IR_DROP_COEFF`, `POST_QUANT_FINE_TUNE_EPOCHS`, `QAT_LR`

## 4. 本次新增/调整的关键改动
### 4.1 输入投影
- 新增两种 784->64 投影输入：PCA 与监督式投影
- 投影后统一缩放/量化到 8‑bit，保证与 SNN/RTL 输入一致

### 4.2 阈值标定
- 阈值比例从“测试子集”改为“训练集划分出的验证集”标定，避免测试集泄漏

### 4.3 Summary 规则
- “最佳方法”改为按 **SNN 准确率** 选择（更符合真实硬件运行）

### 4.4 审查修复（must + should）
- 差分阵列 C2C 由“正负共享一组噪声”改为“正负独立噪声”，避免误差被抵消导致高估准确率
- 自适应阈值推理改为 **每个 bit-plane 都进行 fired 检查/复位**，与主推理路径和 RTL 粒度一致
- 自适应阈值路径补齐读噪声注入（与固定阈值路径一致）
- 脉冲触发条件统一为 `>=`（固定阈值/自适应阈值一致）
- 阈值标定删除 test fallback，仅允许验证集标定（避免潜在数据泄漏）
- 阈值标定从“只标定 best_method”改为“每种方法分别标定”
- 噪声实验统计次数从 full=10 提升到 full=30（quick=5）
- 自适应阈值初值估算从 100 样本提升到可配置样本数（默认 `ADAPTIVE_INIT_SAMPLES=512`），并纳入 ADC 量化链路
- `memristor_plugin.py` 改为模块级缓存，避免重复 `exec_module` 造成不必要开销

### 4.5 运行防污染与可复现机制（新增）
- `run_all.py` 现在会按运行模式自动切换权重目录，避免 `--quick` 覆盖 full 权重：
  - full：`weights_full/`
  - quick：`weights_quick/`
- `config.py` 默认 `WEIGHTS_DIR` 指向 `weights_full/`，因此 `flash_preprocess.py` 等脚本默认读取 full 权重/投影参数
- full run 成功结束后会自动备份（quick 不自动备份）：
  - 备份目录：`backups/full_run_YYYYMMDD_HHMMSS/`
  - 自动备份内容：`results/`、当前权重目录（通常为 `weights_full/`）、`config.py` 快照
  - 自动更新指针：`backups/latest_backup_path.txt`
- 自动生成 `backup_manifest.txt`（可复现证据链），包含：
  - 运行命令、运行模式、耗时、cwd
  - Git 分支 / commit hash / dirty 状态（`git status --short`）
  - `config.py` 快照的时间戳、大小、SHA256
  - `weights/` 与 `results/` 中每个文件的时间戳、大小、SHA256
- 兼容旧工程：首次引入该机制时，会把 legacy `weights/` 中的 `.pt` 文件复制到 `weights_full/`（不删除原文件）

## 5. 硬件落地指南（保证与 Python 完全一致）
如果你要把输入写入 flash，并保证硬件表现匹配 Python：

### 5.1 先跑一次完整训练
```
python run_all.py
```
这会在 `weights_full/` 中自动保存 ANN 权重与投影参数（如 `proj_sup_64_proj_params.pt`）。

说明：
- `python run_all.py --quick` 会写入 `weights_quick/`，仅用于快速调试，不要拿来当定终版权重
- 如果你改了训练流程 / 数据处理 / 投影 / 输入维度 / 量化规则，不要使用 `--skip-train`
- `--skip-train` 只适用于“训练相关逻辑完全不变，仅重跑推理参数扫描/统计”的场景

### 5.2 生成写入 flash 的 64 维输入
使用脚本 `flash_preprocess.py`，它会严格复用训练中保存的投影与缩放规则：

示例（监督投影，导出 test 集）：
```
python flash_preprocess.py --method proj_sup_64 --split test --out results/proj_sup_64_test_uint8.npy
```
输出文件为 `uint8`，shape=[N,64]，可直接写入 flash。


### 5.2.1 将 .npy 转成 flash 可用的 .bin
如果硬件侧更方便读取裸二进制，可以把 `.npy` 转成 `.bin`：

```
python flash_preprocess.py --method proj_sup_64 --split test --out results/proj_sup_64_test_uint8.npy
```

然后在 Python 中执行：
```
import numpy as np
arr = np.load("results/proj_sup_64_test_uint8.npy")
arr.astype(np.uint8).tofile("results/proj_sup_64_test_uint8.bin")
```

`.bin` 内容为顺序排列的 uint8，等价于二维数组按行平铺。

### 5.3 如果是自定义图像
确保图像满足：
- 灰度图，28x28
- uint8，范围 0~255

然后在 Python 中调用：
```
from flash_preprocess import project_and_quantize
features = project_and_quantize(images_28x28, method_name="proj_sup_64")
```
得到的 `features` 就是与模型一致的 64 维输入。

## 6. 关键配置（config.py）
- 路径/结果管理：`RESULTS_DIR`, `WEIGHTS_DIR_FULL`, `WEIGHTS_DIR_QUICK`, `WEIGHTS_DIR`, `DATA_DIR`
- 数据处理：`AUTO_INPUT_GAIN`, `INPUT_GAIN_PERCENTILE`, `INPUT_GAIN_MAX`
- 投影：`PROJ_DIM`, `PROJ_PCA_SAMPLES`, `PROJ_PCA_CENTER`, `PROJ_SCALE_METHOD`, `PROJ_SCALE_PERCENTILE`,
        `PROJ_SUP_EPOCHS`, `PROJ_SUP_LR`, `PROJ_SUP_BATCH_SIZE`, `PROJ_SUP_USE_BIAS`
- 阈值标定：`VAL_SAMPLES`, `CALIBRATE_THRESHOLD_RATIO`, `THRESHOLD_RATIO_CANDIDATES`, `THRESHOLD_CALIBRATE_SAMPLES`
- 自适应阈值：`ADAPTIVE_INIT_SAMPLES`, `SPIKE_RESET_MODE`
- QAT：`QAT_ENABLE`, `QAT_WEIGHT_BITS`, `QAT_USE_DEVICE_LEVELS`, `QAT_NOISE_ENABLE`, `QAT_NOISE_STD`,
        `QAT_IR_DROP_COEFF`, `POST_QUANT_FINE_TUNE_EPOCHS`, `QAT_LR`
- 推理：`SPIKE_THRESHOLD_RATIO`, `ADC_FULL_SCALE_MODE`, `NOISE_TRIALS_QUICK`, `NOISE_TRIALS_FULL`

## 7. Python 定终版前检查清单（建议逐项勾选）
下面这份清单建议在“准备冻结参数 / 更新主文档 / 推 RTL 参数”前逐项确认。

### 7.1 运行方式正确（必须）
- 定终版运行必须使用：
  - 不加 `--quick`
  - 不加 `--skip-train`
- 目的：避免使用 quick 权重或被覆盖的旧权重
- 运行后确认：
  - 日志没有显示 quick 模式
  - 训练阶段确实发生（不是所有方法都 `loaded weights...`）

### 7.2 结果目录与权重快照已冻结（必须）
- full run 完成后，立即冻结本次结果（脚本现在会自动备份）
- 建议使用 `backups/final_run_时间戳/` 或脚本自动生成的 `backups/full_run_时间戳/`
- 至少包含：
  - `results/`
  - `weights_full/`（或本次实际使用的权重目录）
  - `config.py`

### 7.3 版本信息可追溯（必须）
- 至少记录以下信息（脚本自动备份 manifest 已覆盖）：
  - Git commit hash
  - `config.py` 快照
  - 权重文件时间戳
  - 权重文件哈希（建议 SHA256）
- 目的：后续能明确回答“这组 91.24% 对应哪版代码和哪组权重”

### 7.4 检查设备后端状态（必须）
- 查看 `summary.txt` 中 `Device backend` 段，至少应满足：
  - `use_device_model=True`
  - `plugin_path_exists=True`
  - `plugin_levels_loaded=True`
  - `plugin_sim_available=True`
  - `backend_mode=plugin`
- 若出现 fallback / plugin 未加载成功，需要先确认实验口径是否仍可接受

### 7.5 用“硬件对齐口径”确认最终配置（必须）
- 不要只看普通 `Final test`
- 重点检查：
  - `Hardware-aligned (spike-only, no fallback)`（若当前 summary 已输出该项）
  - `zero-spike rate`
- 建议判定规则：
  - Hardware-aligned 与普通 `Final test` 差距要小（例如 `<0.5%`）
  - `zero-spike rate` 不应过高（越低越好）

### 7.6 recommendation vs best-case 取舍合理（必须）
- 你最终是要冻结硬件参数，不是只追“最高精度”
- 需要明确说明：
  - 为什么选 `ADC=8` 或 `ADC=6`
  - 为什么选 `W=4` 或 `W=3`
  - 为什么选 `T=1`
- 建议写进主文档/组会稿：精度收益是否值得对应硬件成本

### 7.7 稳定性检查（建议）
- 查看多 seed 的 `clean / noisy`：
  - 均值是否稳定
  - 标准差是否较小（尤其 noisy）
  - noisy 相比 clean 的退化是否可接受
- 若方差明显偏大，不建议直接定终版

### 7.8 数据口径无泄漏（必须）
- 确认：
  - 调参/阈值标定使用 `val`
  - 最终报告使用 `test`
  - 没有使用 `test` 去调阈值比例 `ratio`
- 这一步是论文/组会高频追问点，必须能明确说明

### 7.9 导出链路可落地（必须）
- 输入导出（Flash）：
  - `flash_preprocess.py` 能按最终 `method` 导出
  - `--check-consistency`（如启用）通过
- 权重导出（器件写阵列）：
  - `export_weight_map.py`（如工程内已有）按最终 `method + weight_bits` 导出成功
  - 输出字段正确（例如 `row,col_pos,col_neg,level_pos,level_neg,G_pos,G_neg`）

### 7.10 与 RTL 参数/接口一致性复核（必须）
- 在宣布 Python 定终版前，逐项对照 RTL / 接口文档：
  - `NUM_INPUTS`
  - `NUM_OUTPUTS`
  - `PIXEL_BITS`
  - `ADC_BITS`
  - `TIMESTEPS_DEFAULT`
  - `Scheme`（A/B）
  - `ADC_CHANNELS`（如差分 10 类对应 20 通道）
  - `THRESHOLD_RATIO_DEFAULT`（若准备同步 RTL 默认值）
- 并同步更新相关文档（如 `SNNSoC工程主文档.md`、接口文档）

### 7.11 额外建议（高性价比）
- `A. 分离目录（已实现）`：`weights_full/` 与 `weights_quick/` 分离，避免 quick 污染 full
- `B. summary 中打印权重路径/mtime/hash（建议后续补）`：可让 `summary.txt` 直接携带权重证据链
- `C. 定终版当天禁止跑 quick（流程建议）`：先冻结与备份，再做其它实验

备注：所有改动均为软件层面，不改变硬件结构/RTL。
